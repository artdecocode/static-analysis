#!/usr/bin/env node
             
const path = require('path');
const fs = require('fs');
const os = require('os');
const _module = require('module');
const stream = require('stream');             const r=(a,b=0,d=!1)=>{if(0===b&&!d)return a;a=a.split("\n",d?b+1:void 0);return d?a[a.length-1]:a.slice(b).join("\n")},u=(a,b=!1)=>r(a,2+(b?1:0)),v=a=>{({callee:{caller:a}}=a);return a};const {homedir:w}=os;const x=/\s+at.*(?:\(|\s)(.*)\)?/,y=/^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:IGNORED_MODULES)\/.*)?\w+)\.js:\d+:\d+)|native)/,A=w(),B=a=>{const {pretty:b=!1,ignoredModules:d=["pirates"]}={},l=d.join("|"),k=new RegExp(y.source.replace("IGNORED_MODULES",l));return a.replace(/\\/g,"/").split("\n").filter(e=>{e=e.match(x);if(null===e||!e[1])return!0;e=e[1];return e.includes(".app/Contents/Resources/electron.asar")||e.includes(".app/Contents/Resources/default_app.asar")?!1:!k.test(e)}).filter(e=>
e.trim()).map(e=>b?e.replace(x,(m,c)=>m.replace(c,c.replace(A,"~"))):e).join("\n")};function C(a,b,d=!1){return function(l){var k=v(arguments),{stack:e}=Error();const m=r(e,2,!0),c=(e=l instanceof Error)?l.message:l;k=[`Error: ${c}`,...null!==k&&a===k||d?[b]:[m,b]].join("\n");k=B(k);return Object.assign(e?l:Error(),{message:c,stack:k})}};function D(a){var {stack:b}=Error();const d=v(arguments);b=u(b,a);return C(d,b,a)};function E(a,b){if(b>a-2)throw Error("Function does not accept that many arguments.");}async function F(a,b,d){const l=D(!0);if("function"!==typeof a)throw Error("Function must be passed.");const {length:k}=a;if(!k)throw Error("Function does not accept any arguments.");return await new Promise((e,m)=>{const c=(f,h)=>f?(f=l(f),m(f)):e(d||h);let g=[c];Array.isArray(b)?(b.forEach((f,h)=>{E(k,h)}),g=[...b,c]):1<Array.from(arguments).length&&(E(k,0),g=[b,c]);a(...g)})};const {createReadStream:G,lstat:H}=fs;const I=async a=>{try{return await F(H,a)}catch(b){return null}};const {dirname:J,join:K,relative:L,resolve:M}=path;const O=async(a,b)=>{b&&(b=J(b),a=K(b,a));var d=await I(a);b=a;let l=!1;if(!d){if(b=await N(a),!b)throw Error(`${a}.js or ${a}.jsx is not found.`);}else if(d.isDirectory()){d=!1;let k;a.endsWith("/")||(k=b=await N(a),d=!0);if(!k){b=await N(K(a,"index"));if(!b)throw Error(`${d?`${a}.jsx? does not exist, and `:""}index.jsx? file is not found in ${a}`);l=!0}}return{path:a.startsWith(".")?L("",b):b,g:l}},N=async a=>{a=`${a}.js`;let b=await I(a);b||(a=`${a}x`);if(b=await I(a))return a};const {builtinModules:P}=_module;const {Writable:Q}=stream;const R=(a,b)=>{b.once("error",d=>{a.emit("error",d)});return b};class S extends Q{constructor(a){const {binary:b=!1,rs:d=null,...l}=a||{},{f:k=D(!0),proxyError:e}=a||{},m=(c,g)=>k(g);super(l);this.a=[];this.b=new Promise((c,g)=>{this.on("finish",()=>{let f;b?f=Buffer.concat(this.a):f=this.a.join("");c(f);this.a=[]});this.once("error",f=>{if(-1==f.stack.indexOf("\n"))m`${f}`;else{const h=B(f.stack);f.stack=h;e&&m`${f}`}g(f)});d&&R(this,d).pipe(this)})}_write(a,b,d){this.a.push(a);d()}get c(){return this.b}}const T=async a=>{({c:a}=new S({rs:a,f:D(!0)}));return await a};async function U(a){a=G(a);return await T(a)};function V(a,b){var d=["q","from"];const l=[];b.replace(a,(k,...e)=>{k=e.slice(0,e.length-2).reduce((m,c,g)=>{g=d[g];if(!g||void 0===c)return m;m[g]=c;return m},{});l.push(k)});return l};const aa=/^ *import(?:\s+(?:[^\s,]+)\s*,?)?(?:\s*{(?:[^}]+)})?\s+from\s+(['"])(.+?)\1/gm,ba=/^ *import\s+(?:.+?\s*,\s*)?\*\s+as\s+.+?\s+from\s+(['"])(.+?)\1/gm,ca=/^ *import\s+(['"])(.+?)\1/gm,da=/^ *export\s+(?:{[^}]+?}|\*)\s+from\s+(['"])(.+?)\1/gm,ea=a=>[aa,ba,ca,da].reduce((b,d)=>{d=V(d,a).map(l=>l.from);return[...b,...d]},[]);const W=async(a,b,d={})=>{const {fields:l,soft:k=!1}=d;var e=K(a,"node_modules",b);e=K(e,"package.json");const m=await I(e);if(m){a=await fa(e,l);if(void 0===a)throw Error(`The package ${L("",e)} does export the module.`);if(!a.entryExists&&!k)throw Error(`The exported module ${a.main} in package ${b} does not exist.`);const {entry:c,version:g,packageName:f,main:h,entryExists:p,...n}=a;return{entry:L("",c),packageJson:L("",e),...g?{version:g}:{},packageName:f,...h?{hasMain:!0}:{},...p?{}:{entryExists:!1},
...n}}if("/"==a&&!m)throw Error(`Package.json for module ${b} not found.`);return W(K(M(a),".."),b,d)},fa=async(a,b=[])=>{const d=await U(a);let l,k,e,m,c;try{({module:l,version:k,name:e,main:m,...c}=JSON.parse(d)),c=b.reduce((f,h)=>{f[h]=c[h];return f},{})}catch(f){throw Error(`Could not parse ${a}.`);}a=J(a);b=l||m;if(!b){if(!await I(K(a,"index.js")))return;b=m="index.js"}a=K(a,b);let g;try{({path:g}=await O(a)),a=g}catch(f){}return{entry:a,version:k,packageName:e,main:!l&&m,entryExists:!!g,...c}};const X=a=>/^[./]/.test(a),Y=async(a,b,d,l,k=null)=>{const e=D(),m=J(a);b=b.map(async c=>{if(P.includes(c))return{internal:c};if(/^[./]/.test(c))try{var {path:g}=await O(c,a);return{entry:g,package:k}}catch(f){}else{{let [p,n,...q]=c.split("/");!p.startsWith("@")&&n?(q=[n,...q],n=p):n=p.startsWith("@")?`${p}/${n}`:p;g={name:n,paths:q.join("/")}}const {name:f,paths:h}=g;if(h){const {packageJson:p,packageName:n}=await W(m,f);c=J(p);({path:c}=await O(K(c,h)));return{entry:c,package:n}}}try{const {entry:f,
packageJson:h,version:p,packageName:n,hasMain:q,...t}=await W(m,c,{fields:l});return n==k?(console.warn("[static-analysis] Skipping package %s that imports itself in %s",n,a),null):{entry:f,packageJson:h,version:p,name:n,...q?{hasMain:q}:{},...t}}catch(f){if(d)return null;throw e(f);}});return(await Promise.all(b)).filter(Boolean)},Z=async(a,b={},{nodeModules:d=!0,shallow:l=!1,soft:k=!1,fields:e=[],package:m}={})=>{if(a in b)return[];b[a]=1;var c=await U(a),g=ea(c);c=ha(c);g=d?g:g.filter(X);c=d?c:
c.filter(X);let f;try{const h=await Y(a,g,k,e,m),p=await Y(a,c,k,e,m);p.forEach(n=>{n.required=!0});f=[...h,...p]}catch(h){throw h.message=`${a}\n [!] ${h.message}`,h;}m=f.map(h=>({...h,from:a}));return await f.filter(({entry:h})=>h&&!(h in b)).reduce(async(h,{entry:p,hasMain:n,packageJson:q,name:t,package:ia})=>{if(q&&l)return h;h=await h;t=(await Z(p,b,{nodeModules:d,shallow:l,soft:k,fields:e,package:t||ia})).map(z=>({...z,from:z.from?z.from:p,...!z.packageJson&&n?{hasMain:n}:{}}));return[...h,
...t]},m)},ha=a=>V(/(?:^|[^\w\d_])require\(\s*(['"])(.+?)\1\s*\)/gm,a).map(b=>b.from);module.exports={_staticAnalysis:async(a,b={})=>{const d=D();({path:a}=await O(a));const {nodeModules:l=!0,shallow:k=!1,soft:e=!1,fields:m=[]}=b;let c;try{c=await Z(a,{},{nodeModules:l,shallow:k,soft:e,fields:m})}catch(g){throw d(g);}return c.filter(({internal:g,entry:f},h)=>g?c.findIndex(({internal:p})=>p==g)==h:c.findIndex(({entry:p})=>f==p)==h).map(g=>{const {entry:f,internal:h}=g,p=c.filter(({internal:n,entry:q})=>{if(h)return h==n;if(f)return f==q}).map(({from:n})=>n).filter((n,q,t)=>t.indexOf(n)==
q);return{...g,from:p}}).map(({package:g,...f})=>g?{package:g,...f}:f)}};

//# sourceMappingURL=depack.js.map