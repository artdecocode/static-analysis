{
"version":3,
"file":"compile/depack.js",
"lineCount":13,
"mappings":"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",
"sources":["node_modules/erotic/src/lib.js","node_modules/os/index.js","node_modules/@artdeco/clean-stack/src/index.js","node_modules/erotic/src/callback.js","node_modules/erotic/src/index.js","node_modules/makepromise/src/index.js","node_modules/fs/index.js","node_modules/@wrote/exists/src/index.js","node_modules/path/index.js","node_modules/resolve-dependency/src/index.js","node_modules/module/index.js","node_modules/stream/index.js","node_modules/catchment/src/lib/index.js","node_modules/catchment/src/index.js","node_modules/@wrote/read/src/index.js","node_modules/mismatch/src/index.js","node_modules/@depack/detect/src/index.js","node_modules/fpj/src/index.js","src/lib.js","node_modules/@depack/split/src/index.js","src/depack.js","src/index.js"],
"sourcesContent":["const getLastItem = (array) => {\n  const item = array[array.length - 1]\n  return item\n}\nconst getItemsFrom = (array, from) => array.slice(from)\n\n/**\n * Get a segment of the stack string, defaults are from = 0 and oneLine = false.\n * @param {string} stack the stack string\n * @param {number} [from=0] index from which to slice from\n * @param {boolean} [oneLine=false] Whether just first line must be returned\n * @returns {string} A stack segment starting from the specified line.\n */\nexport const getStackSegment = (stack, from = 0, oneLine = false) => {\n  if (from === 0 && !oneLine) {\n    return stack\n  }\n  const splitStack = stack\n    .split('\\n', oneLine ? from + 1 : undefined)\n  if (oneLine) {\n    const line = getLastItem(splitStack)\n    return line\n  } else {\n    const items = getItemsFrom(splitStack, from)\n    return items.join('\\n')\n  }\n}\n\n/**\n * Get the stack trace part of when the erotic function was called. Disregards\n * first two lines.\n * @param {string} stack error's stack\n * @param {boolean} [transparent] trim the top line as well\n * @returns {string} A part of stack\n */\nexport const getEntryStack = (stack, transparent = false) => {\n  const stackSegment = getStackSegment(stack, 2 + (transparent ? 1 : 0))\n  return stackSegment\n}\n\n/**\n * Get stack line of where the callback was called.\n * @param {string} stack Stack string.\n * @returns {string} Stack line.\n */\nexport const getCalleeStackLine = (stack) => {\n  const calleeStackLine = getStackSegment(stack, 2, true)\n  return calleeStackLine\n}\n\nexport const getStackHeading = message => `Error: ${message}`\n\n/**\n * Extract caller from the function's `arguments`.\n * @param {Object} args arguments\n * @returns {!Function} The caller function from `arguments.callee.caller`.\n */\nexport const getCallerFromArguments = (args) => {\n  const { callee: { caller } } = args\n  return caller\n}","export default os\nexport const {\n  EOL,\n  arch,\n  constants,\n  cpus,\n  endianness,\n  freemem,\n  homedir,\n  hostname,\n  loadavg,\n  networkInterfaces,\n  platform,\n  release,\n  tmpdir,\n  totalmem,\n  type,\n  uptime,\n  userInfo,\n} = os","import { homedir } from 'os'\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:IGNORED_MODULES)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/\n\nconst homeDir = homedir()\n\n/**\n * Remove internal Node.JS lines from the error stack traces.\n * @param {string} stack The error stack to update.\n * @param {!_cleanStack.Config} [options] Options for the program.\n * @param {boolean} [options.pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @param {!Array<string>} [options.ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\nconst cleanStack = (stack, options) => {\n  const {\n    pretty = false, ignoredModules = ['pirates'],\n  } = options || {}\n  const j = ignoredModules.join('|')\n  const re = new RegExp(pathRegex.source.replace('IGNORED_MODULES', j))\n\n  return stack.replace(/\\\\/g, '/')\n    .split('\\n')\n    .filter(x => {\n      const pathMatches = x.match(extractPathRegex)\n      if (pathMatches === null || !pathMatches[1]) {\n        return true\n      }\n\n      const match = pathMatches[1]\n\n      // Electron\n      if (match.includes('.app/Contents/Resources/electron.asar') ||\n        match.includes('.app/Contents/Resources/default_app.asar')) {\n        return false\n      }\n\n      return !re.test(match)\n    })\n    .filter(x => x.trim())\n    .map(x => {\n      if (pretty) {\n        return x.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')))\n      }\n\n      return x\n    })\n    .join('\\n')\n}\n\nexport default cleanStack\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_cleanStack.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _cleanStack.Config Options for the program.\n * @prop {boolean} [pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @prop {!Array<string>} [ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\n","import cleanStack from '@artdeco/clean-stack'\nimport {\n  getCallerFromArguments, getCalleeStackLine, getStackHeading,\n} from './lib'\n\n/**\n * Create a callback.\n * @param {!Function} entryCaller The function which was called at entry.\n * @param {string} entryStack The first line of the error stack to be returned\n * @param {boolean} [shadow=false] Print only entry stack.\n */\nexport function makeCallback(entryCaller, entryStack, shadow = false) {\n  /**\n   * This callback should be called when an asynchronous error occurred.\n   * @param {(string|Error)} messageOrError A message string or an _Error_ object at the point of actual error.\n   * @returns {Error} An error with the updated stack which includes the callee.\n   */\n  function cb(messageOrError) {\n    const caller = getCallerFromArguments(arguments)\n    const { stack: errorStack } = new Error()\n    const calleeStackLine = getCalleeStackLine(errorStack)\n    const isError = messageOrError instanceof Error\n    const message = isError ? messageOrError.message : messageOrError\n\n    const stackHeading = getStackHeading(message)\n    const entryHasCallee = caller !== null && entryCaller === caller\n    const stackMessage = [\n      stackHeading,\n      ...(entryHasCallee || shadow ? [entryStack] : [\n        calleeStackLine,\n        entryStack,\n      ]),\n    ].join('\\n')\n\n    const stack = cleanStack(stackMessage)\n    const properties = { message, stack }\n    const e = isError ? messageOrError : new Error()\n\n    return /** @type {Error} */ (Object.assign(/** @type {!Object} */ (e), properties))\n  }\n\n  return cb\n}","import {\n  getEntryStack, getCallerFromArguments,\n} from './lib'\nimport { makeCallback } from './callback'\n\n/**\n * Returns a function to create an error with a stack trace starting at the line in code when the call was made by the callee.\n * @param {boolean} [transparent] Pretend as if the call to the function lead to the error, without exposing any of the internal stack.\n */\nexport default function erotic(transparent) {\n  const { stack } = new Error()\n  const caller = getCallerFromArguments(arguments)\n  const entryStack = getEntryStack(stack, transparent)\n\n  return makeCallback(caller, entryStack, transparent)\n}","import erotic from 'erotic'\n\nfunction checkArgumentIndex(length, i) {\n  if (i > length - 2) {\n    throw new Error('Function does not accept that many arguments.')\n  }\n}\n\n/**\n * Get a promise from a function which otherwise accepts a callback.\n * @param {Function} fn A function to promisify.\n * @param {*|Array<*>} [args] An array of arguments to use in the call, or a single argument.\n * @param {*} [resolveValue] A value to override the value with which the promise will be resolved.\n * @returns {Promise<*>} A promise resolved on callback invocation without an error and rejected on callback called with an error.\n */\nexport default async function makePromise(fn, args, resolveValue) {\n  const er = erotic(true)\n  if (typeof fn !== 'function') {\n    throw new Error('Function must be passed.')\n  }\n  const { length: fnLength } = fn\n  if (!fnLength) {\n    throw new Error('Function does not accept any arguments.')\n  }\n\n  const res = await new Promise((resolve, reject)=> {\n    const cb = (err, res) => {\n      if (err) {\n        const error = er(err)\n        return reject(error)\n      }\n      return resolve(resolveValue || res)\n    }\n\n    let allArgs = [cb]\n\n    if (Array.isArray(args)) {\n      args.forEach((arg, i) => {\n        checkArgumentIndex(fnLength, i)\n      })\n      allArgs =  [...args, cb]\n    } else if (Array.from(arguments).length > 1) { // args passed as a single argument, not array\n      checkArgumentIndex(fnLength, 0)\n      allArgs = [args, cb]\n    }\n    fn(...allArgs)\n  })\n  return res\n}","export default fs\nexport const {\n  ReadStream,\n  Stats,\n  WriteStream,\n  access,\n  accessSync,\n  appendFile,\n  appendFileSync,\n  chmod,\n  chmodSync,\n  chown,\n  chownSync,\n  close,\n  closeSync,\n  constants,\n  copyFile,\n  copyFileSync,\n  createReadStream,\n  createWriteStream,\n  exists,\n  existsSync,\n  fchmod,\n  fchmodSync,\n  fchown,\n  fchownSync,\n  fdatasync,\n  fdatasyncSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchmod,\n  lchmodSync,\n  lchown,\n  lchownSync,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  read,\n  readFile,\n  readFileSync,\n  readSync,\n  readdir,\n  readdirSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unlink,\n  unlinkSync,\n  unwatchFile,\n  utimes,\n  utimesSync,\n  watch,\n  watchFile,\n  write,\n  writeFile,\n  writeFileSync,\n  writeSync,\n} = fs","import makePromise from 'makepromise'\nimport { lstat } from 'fs'\n\n/**\n * Check If The File Or Directory Exists, And Return Stats.\n * @param {string} path The path to check for existence.\n */\nconst exists = async (path) => {\n  try {\n    const ls = /** @type {fs.Stats} */ (await makePromise(lstat, path))\n    return ls\n  } catch (err) {\n    return null\n  }\n}\n\nexport default exists\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */","export default path\nexport const {\n  basename,\n  delimiter,\n  dirname,\n  extname,\n  format,\n  isAbsolute,\n  join,\n  normalize,\n  parse,\n  posix,\n  relative,\n  resolve,\n  sep,\n  win32,\n} = path","import exists from '@wrote/exists'\nimport { dirname, join, relative } from 'path'\n\n/**\n * For the given local path that can omit the JS/JSX extension and point to a directory (e.g., `./lib` or `./lib/example`), find that file on the filesystem.\n * @param {string} path The dependency path, to resolve e.g., `./lib`.\n * @param {string} [relativeFrom] The optional path of the file that imports the given path.\n */\nconst resolveDependency = async (path, relativeFrom) => {\n  if (relativeFrom) {\n    const d = dirname(relativeFrom)\n    path = join(d, path)\n  }\n  let e = await exists(path)\n  let res = path\n  let isDir = false\n  if (!e) {\n    res = await checkSources(path)\n    if (!res) throw new Error(`${path}.js or ${path}.jsx is not found.`)\n  } else if (e.isDirectory()) {\n    // first try file\n    let fileChecked = false\n    let fileRes\n    if (!path.endsWith('/')) {\n      fileRes = res = await checkSources(path)\n      fileChecked = true\n    }\n    if (!fileRes) {\n      res = await checkSources(join(path, 'index'))\n      if (!res) {\n        const s = fileChecked ? `${path}.jsx? does not exist, and ` : ''\n        throw new Error(`${s}index.jsx? file is not found in ${path}`)\n      }\n      isDir = true\n    }\n  }\n  return {\n    path: path.startsWith('.') ? relative('', res) : res,\n    isDir,\n  }\n}\n\nconst checkSources = async (path) => {\n  let pp = `${path}.js`\n  let e = await exists(pp)\n  if (!e) pp = `${pp}x`; e = await exists(pp)\n  if (e) return pp\n}\n\nexport default resolveDependency","export default _module\nexport const {\n  Module,\n  builtinModules,\n  runMain,\n  wrap,\n} = _module","export default stream\nexport const {\n  Duplex,\n  PassThrough,\n  Readable,\n  Stream,\n  Transform,\n  Writable,\n} = stream","/**\n * Listens for the `error` event once so that when an error in _streamB_ is emitted, is is also emitted in the _streamA_.\n * @param {stream.Stream} streamA The stream that will emit an error once it's caught in the `streamB`.\n * @param {stream.Stream} streamB The stream from which the error originates.\n * @returns The stream the error is listened on, i.e., transparent to calling the `.once` method on that stream.\n */\nexport const pipeError = (streamA, streamB) => {\n  streamB\n    .once('error', e => {\n      streamA.emit('error', e)\n    })\n  return streamB\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Stream} stream.Stream\n */","import { Writable } from 'stream'\nimport erotic from 'erotic'\nimport cleanStack from '@artdeco/clean-stack'\nimport { pipeError } from './lib'\n\nfunction joinBufferData(array) {\n  return array.join('')\n}\n\n/**\n * A writable stream which collects incoming data into memory, and provides a promise to way for the stream to finish. The promise is resolved with joined chunks.\n */\nexport default class Catchment extends Writable {\n  /**\n   * Create a new catchment to pipe a readable stream into and collect all emitted data.\n   * @param {!_catchment.Options} [options] Options to pass to the `Writable` super constructor, and others shown below.\n   * @param {!stream.Readable} [options.rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n   * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n   * @example\n   *\n   * import { createReadStream } from 'fs'\n   * import Catchment from 'catchment'\n   *\n   * const rs = createReadStream('file.txt')\n   * const { promise } = new Catchment({ rs })\n   * const res = await promise\n   */\n  constructor(options) {\n    const {\n      binary = false, rs = null, ...opts\n    } = options || {}\n    /** @suppress {missingProperties} */\n    const { er = erotic(true), proxyError } = options || {}\n    const wrap = (_, e) => er(e)\n    super(/** @type {!stream.WritableOptions} */ (opts))\n    this._caughtData = []\n    this._promise = new Promise((r, j) => {\n      this.on('finish', () => {\n        let d\n        if (binary) {\n          d = Buffer.concat(this._caughtData)\n        } else {\n          d = joinBufferData(this._caughtData)\n        }\n        r(d)\n        this._caughtData = []\n      })\n      this.once('error', (e) => {\n        if (e.stack.indexOf('\\n') == -1) {\n          wrap`${e}`\n          j(e)\n        } else {\n          const stack = cleanStack(e.stack)\n          e.stack = stack\n          if (proxyError) wrap`${e}`\n          j(e)\n        }\n      })\n      if (rs) {\n        pipeError(this, rs).pipe(this)\n      }\n    })\n  }\n  _write(chunk, encoding, callback) {\n    this._caughtData.push(chunk)\n    callback()\n  }\n  /**\n   * A promise which will resolve will all data when the stream finishes.\n   * @type {Promise<string|Buffer>}\n   */\n  get promise() {\n    return this._promise\n  }\n}\n\n/**\n * Collect data into a catchment, and return results when the stream finishes.\n * @param {stream.Readable} readable A readable stream to collect all data from. If an error occurs during reading of this stream, the promise will be rejected with it.\n * @param {_catchment.CollectOptions} options Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @param {boolean} [options.proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n * @example\n *\n * import { collect } from 'catchment'\n * import { createReadStream } from 'fs'\n *\n * const rs = createReadStream(path)\n * await collect(rs, { proxyError: true })\n */\nexport const collect = async (readable, options = {}) => {\n  const { promise } = new Catchment({\n    rs: readable,\n    ...options,\n    er: erotic(true),\n  })\n  const res = await promise\n  return res\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.Options} Options Options to pass to the `Writable` super constructor, and others shown below.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.Options Options to pass to the `Writable` super constructor, and others shown below.\n * @prop {!stream.Readable} [rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n\n/* typal types/collect.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.CollectOptions} CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @prop {boolean} [proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n */\n","import { createReadStream } from 'fs'\nimport { collect } from 'catchment'\n\n/**\n * Read a file.\n * @param {string} path The path to the file to read.\n */\nexport default async function read(path) {\n  const rs = createReadStream(path)\n  /** @type {string} */\n  const res = await collect(rs)\n  return res\n}\n\n/**\n * Read a file as a buffer.\n * @param {string} path The path to the file to read.\n */\nexport async function readBuffer(path) {\n  const rs = createReadStream(path)\n  /** @type {Buffer} */\n  const res = await collect(rs, { binary: true })\n  return res\n}","/**\n * Returns an array of captured groups of a regular expression as objects. Does not modify the `lastIndex` property of the regex.\n * @param {RegExp} re The regular expression used for matching.\n * @param {string} string String to find matches in.\n * @param {Array<string>} keys Keys to use to create an captured group object.\n * @param {boolean} addPositions Whether to include positions in the return.\n * @example\n *\n```js\nconst re = /(test) inside of a (string)(\\d)?/ig\nconst s = 'Test inside of a STRING1. TEST inside of a string.'\nconst keys = ['test', 'string', 'number']\nconst res = mismatch(re, s, keys)\n\n// result:\n[\n {\n   test: 'Test',\n   string: 'STRING',\n   number: '1',\n },\n {\n   test: 'TEST',\n   string: 'string',\n },\n]\n```\n */\nexport default function mismatch(re, string, keys, addPositions = false) {\n  /** @type {!Array<!Object<string, string>>} */\n  const m = []\n  string.replace(re, (match, ...args) => {\n    // remove position and input\n    const position = args[args.length - 2]\n    const start = addPositions ? { position } : {}\n    const p = args.slice(0, args.length - 2)\n    const o = p.reduce((acc, capturedGroup, i) => {\n      const key = keys[i]\n      if (!(key && capturedGroup !== undefined)) return acc\n      acc[key] = capturedGroup\n      return acc\n    }, start)\n    m.push(o)\n  })\n  return m\n}","import mismatch from 'mismatch'\n\nconst RE = /^ *import(?:\\s+(?:[^\\s,]+)\\s*,?)?(?:\\s*{(?:[^}]+)})?\\s+from\\s+(['\"])(.+?)\\1/gm\nconst RE2 = /^ *import\\s+(?:.+?\\s*,\\s*)?\\*\\s+as\\s+.+?\\s+from\\s+(['\"])(.+?)\\1/gm\nconst RE3 = /^ *import\\s+(['\"])(.+?)\\1/gm\nconst RE4 = /^ *export\\s+(?:{[^}]+?}|\\*)\\s+from\\s+(['\"])(.+?)\\1/gm\n\n/**\n * Returns the names of the modules imported with `import` and `export` statements.\n * @param {string} source The source to detect matches in.\n */\nconst getMatches = (source) => {\n  const res = [RE, RE2, RE3, RE4].reduce((acc, re) => {\n    const m = mismatch(re, source, ['q', 'from'])\n      .map(a => a['from'])\n    return [...acc, ...m]\n  }, [])\n  return res\n}\n\nexport default getMatches\n\nexport const RES = {\n  RE, RE2, RE3, RE4,\n}","import { join, relative, resolve, dirname } from 'path'\nimport exists from '@wrote/exists'\nimport read from '@wrote/read'\nimport resolveDep from 'resolve-dependency'\n\n/**\n * Finds the location of the `package.json` for the given dependency in the directory, and its entry file.\n * @param {string} dir The path to the directory where the requiring file is located.\n * @param {string} name The name of the required package.\n * @param {!_fpj.Config} opts The options for `fpj`.\n * @param {!Array<string>} [opts.fields] Any additional fields from `package.json` file to return.\n * @param {boolean} [opts.soft=false] If the entry export (main or module) does not exist, `soft` mode will not throw an error, but add the `hasEntry` property to the output set to _false_. Default `false`.\n * @returns {!Promise<!_fpj.Return>}\n */\nconst findPackageJson = async (dir, name, opts = {}) => {\n  const { fields, soft = false } = opts\n  const fold = join(dir, 'node_modules', name)\n  const path = join(fold, 'package.json')\n  const e = await exists(path)\n  if (e) {\n    const res = await findEntry(path, fields)\n    if (res === undefined)\n      throw new Error(`The package ${relative('', path)} does export the module.`)\n    else if (!res.entryExists && !soft)\n      throw new Error(`The exported module ${res.main} in package ${name} does not exist.`)\n    const { entry, version, packageName, main, entryExists, ...rest } = res\n    const result = /** @type {!_fpj.Return} */ ({\n      entry: relative('', entry),\n      packageJson: relative('', path),\n      ...(version ? { version } : {}),\n      packageName,\n      ...(main ? { hasMain: true } : {}),\n      ...(!entryExists ? { entryExists: false } : {}),\n      ...rest,\n    })\n    return result\n  }\n  if (dir == '/' && !e)\n    throw new Error(`Package.json for module ${name} not found.`)\n  return findPackageJson(join(resolve(dir), '..'), name, opts)\n}\n\n/**\n * Finds the path to the entry based on package.json file.\n * @param {string} path\n * @param {!Array<string>} fields\n */\nexport const findEntry = async (path, fields = []) => {\n  const f = await read(path)\n  let mod, version, packageName, main, rest\n  try {\n    ({\n      'module': mod,\n      'version': version,\n      'name': packageName,\n      'main': main,\n      ...rest\n    } = JSON.parse(f))\n    rest = fields.reduce((acc, current) => {\n      acc[current] = rest[current]\n      return acc\n    }, {})\n  } catch (err) {\n    throw new Error(`Could not parse ${path}.`)\n  }\n  const dir = dirname(path)\n  let resolved = mod || main\n  if (!resolved) {\n    const indexExists = await exists(join(dir, 'index.js'))\n    if (!indexExists) return undefined\n    resolved = main = 'index.js'\n  }\n  let entry = join(dir, resolved)\n  let r\n  try {\n    ({ path: r } = await resolveDep(entry))\n    entry = r\n  } catch (err) {/* does not exist */}\n  return { entry, version, packageName, main: !mod && main,\n    entryExists: !!r,\n    ...rest }\n}\n\nexport default findPackageJson\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_fpj.Config} Config The options for `fpj`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _fpj.Config The options for `fpj`.\n * @prop {!Array<string>} [fields] Any additional fields from `package.json` file to return.\n * @prop {boolean} [soft=false] If the entry export (main or module) does not exist, `soft` mode will not throw an error, but add the `hasEntry` property to the output set to _false_. Default `false`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_fpj.Return} Return The return type of the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _fpj.Return The return type of the program.\n * @prop {string} entry The location of the package's entry file. The preference is given to the `module` field.\n * @prop {string} packageJson The path to the package.json file itself.\n * @prop {string} packageName The name of the resolved package.\n * @prop {string} [version] The version of the package.\n * @prop {boolean} [hasMain] Whether the entry is the `main` rather than `module`.\n * @prop {boolean} [entryExists] In soft mode, will be set to `false` if the entry file does not exist.\n */\n","import { dirname, join } from 'path'\nimport { builtinModules } from 'module'\nimport read from '@wrote/read'\nimport resolveDependency from 'resolve-dependency'\nimport getMatches from '@depack/detect'\nimport split from '@depack/split'\nimport findPackageJson from 'fpj'\nimport mismatch from 'mismatch'\nimport erotic from 'erotic'\n\nexport const checkIfLib = modName => /^[./]/.test(modName)\n\n/**\n * Expands the dependency match to include `package.json` and entry paths.\n * @param {string} path The path to the file.\n * @param {!Array<string>} matches The matches.\n * @param {boolean} [soft] Whether to throw when a dependency's package.json is not found.\n * @param {!Array<string>} [fields] What additional fields to fetch from package.json.\n * @returns {!Promise<!Array<!_staticAnalysis.DependencyMeta>>}\n */\nconst getDependenciesMeta = async (path, matches, soft, fields, pckg = null) => {\n  const e = erotic()\n  const dir = dirname(path)\n  const proms = matches.map(async (name) => {\n    const internal = builtinModules.includes(name)\n    if (internal) return { internal: name }\n    const isLib = checkIfLib(name)\n    if (isLib) {\n      try {\n        const { path: entry } = await resolveDependency(name, path)\n        return { entry, package: pckg }\n      } catch (err) { /*\n        maybe a local package with package.json\n      */}\n    } else {\n      const { name: n, paths } = split(name)\n      if (paths) {\n        const { packageJson, packageName } = await findPackageJson(dir, n)\n        const d = dirname(packageJson)\n        const { path: entry } = await resolveDependency(join(d, paths))\n        return { entry, package: packageName }\n      }\n    }\n    try {\n      const {\n        entry, packageJson, version, packageName, hasMain, ...rest\n      } = await findPackageJson(dir, name, { fields })\n      if (packageName == pckg) {\n        console.warn('[static-analysis] Skipping package %s that imports itself in %s', packageName, path)\n        return null\n      }\n      return {\n        entry, packageJson, version, name: packageName,\n        ...(hasMain ? { hasMain } : {}),\n        ...rest }\n    } catch (err) {\n      if (soft) return null\n      throw e(err)\n    }\n  })\n  return (await Promise.all(proms)).filter(Boolean)\n}\n\n/**\n * Detects the imports.\n * @param {string} path\n * @param {Object} cache\n * @returns {!Promise<!Array<!_staticAnalysis.Detection>>}\n */\nexport const detect = async (path, cache = {}, {\n  nodeModules = true, shallow = false, soft = false, fields = [],\n  package: pckg } = {}) => {\n  if (path in cache) return []\n  cache[path] = 1\n  const source = await read(path)\n  const matches = getMatches(source)\n  const requireMatches = getRequireMatches(source)\n  const fm = nodeModules ? matches : matches.filter(checkIfLib)\n  const fr = nodeModules ? requireMatches : requireMatches.filter(checkIfLib)\n\n  let deps\n  try {\n    const dm = await getDependenciesMeta(path, fm, soft, fields, pckg)\n    const rm = await getDependenciesMeta(path, fr, soft, fields, pckg)\n    rm.forEach((val) => {\n      val.required = true\n    })\n    deps = [...dm, ...rm]\n  } catch (err) {\n    err.message = `${path}\\n [!] ${err.message}`\n    throw err\n  }\n  const d = deps.map(o => ({ ...o, from: path }))\n  const entries = deps\n    .filter(({ entry }) => entry && !(entry in cache))\n  const discovered = await entries\n    .reduce(async (acc, {\n      entry, hasMain, packageJson, name, package: p }) => {\n      if (packageJson && shallow) return acc\n      const accRes = await acc\n      const res = await detect(entry, cache, { nodeModules, shallow, soft, fields, package: name || p })\n      const r = res\n        .map(o => ({\n          ...o,\n          from: o.from ? o.from : entry,\n          ...(!o.packageJson && hasMain ? { hasMain } : {}),\n        }))\n      return [...accRes, ...r]\n    }, d)\n  return discovered\n}\n\nexport const getRequireMatches = (source) => {\n  const m = mismatch(/(?:^|[^\\w\\d_])require\\(\\s*(['\"])(.+?)\\1\\s*\\)/gm, source, ['q', 'from'])\n  const res = m.map(a => a['from'])\n  return res\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Detection} _staticAnalysis.Detection\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').DependencyMeta} _staticAnalysis.DependencyMeta\n */","/**\n * Splits the package name possibly with scope and returns the name and the\n * path within that page that was required.\n * @param {string} from The package, e.g., `@depack/depack/src`, or `depack`.\n */\nconst split = (from) => {\n  let [scope, name, ...paths] = from.split('/')\n  if (!scope.startsWith('@') && name) {\n    paths = [name, ...paths]\n    name = scope\n  } else if (!scope.startsWith('@')) {\n    name = scope\n  } else {\n    name = `${scope}/${name}`\n  }\n  return { name, paths: paths.join('/') }\n}\n\nexport default split","import '../types/externs'\nimport staticAnalysis from './'\n\nmodule.exports = {\n  '_staticAnalysis': staticAnalysis,\n}","import resolveDependency from 'resolve-dependency'\nimport erotic from 'erotic'\nimport { detect } from './lib'\n\n/**\n * Detects all dependencies in a file and their dependencies recursively.\n * @param {!Array<string>|string} path The path to the file in which to detect dependencies.\n * @param {!_staticAnalysis.Config} [config] The configuration options for `staticAnalysis`.\n * @return {!Promise<!Array<_staticAnalysis.Detection>>}\n */\nconst staticAnalysis = async (path, config = {}) => {\n  const e = erotic()\n  let paths = Array.isArray(path) ? path : [path]\n  paths = await Promise.all(paths.map(async p => {\n    const { path: pp } = await resolveDependency(p)\n    return pp\n  }))\n\n  const {\n    nodeModules = true,\n    shallow = false,\n    soft = false,\n    fields = [],\n  } = config\n  let detected\n  try {\n    const cache = {}\n\n    detected = await paths.reduce(async (acc, p) => {\n      acc = await acc\n      const res = await detect(p, cache, {\n        nodeModules, shallow, soft, fields })\n      acc.push(...res)\n      return acc\n    }, [])\n  } catch (err) {\n    throw e(err)\n  }\n  const filtered = detected.filter(({ internal, entry }, i) => {\n    if (internal) {\n      const fi = detected.findIndex(({ internal: ii }) => {\n        return ii == internal\n      })\n      return fi == i\n    }\n    const ei = detected.findIndex(({ entry: ee }) => {\n      return entry == ee\n    })\n    return ei == i\n  })\n  const f = filtered.map((ff) => {\n    const { entry, internal } = ff\n    const froms = detected\n      .filter(({ internal: i, entry: ee }) => {\n        if (internal) return internal == i\n        if (entry) return entry == ee\n      })\n      .map(({ from }) => from)\n      .filter((el, i, a) => a.indexOf(el) == i)\n    const newF =  { ...ff, from: froms }\n    return newF\n  })\n    .map(({ package: pckg, ...props }) => {\n      if (pckg) return { package: pckg, ...props }\n      return props\n    })\n  return f\n}\n\n/**\n * Sorts the detected dependencies into commonJS modules, packageJsons and internals.\n * @param {!Array<!_staticAnalysis.Detection>} detected The detected matches\n */\nexport const sort = (detected) => {\n  const packageJsons = []\n  const commonJsPackageJsons = []\n  const commonJs = []\n  const js = []\n  const internals = []\n  const deps = []\n  detected\n    .forEach(({ packageJson, hasMain, name, entry, internal }) => {\n      if (internal) return internals.push(internal)\n\n      if (packageJson && hasMain)\n        commonJsPackageJsons.push(packageJson)\n      else if (packageJson) packageJsons.push(packageJson)\n      if (entry && hasMain) commonJs.push(entry)\n      else if (entry) js.push(entry)\n      if (name) deps.push(name)\n    })\n  return { commonJsPackageJsons,\n    packageJsons, commonJs, js, internals, deps }\n}\n\nexport default staticAnalysis\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../').Config} _staticAnalysis.Config\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../').Detection} _staticAnalysis.Detection\n */"],
"names":["getStackSegment","stack","from","oneLine","splitStack","split","undefined","item","length","slice","items","join","getEntryStack","transparent","stackSegment","getCallerFromArguments","args","caller","homedir","os","extractPathRegex","pathRegex","homeDir","cleanStack","pretty","ignoredModules","j","re","RegExp","source","replace","filter","x","pathMatches","match","includes","test","trim","map","m","p1","makeCallback","entryCaller","entryStack","shadow","cb","messageOrError","arguments","errorStack","Error","calleeStackLine","message","isError","stackMessage","stackHeading","Object","assign","e","properties","erotic","checkArgumentIndex","i","makePromise","fn","resolveValue","er","fnLength","res","Promise","resolve","reject","err","error","allArgs","Array","isArray","forEach","arg","createReadStream","lstat","fs","exists","path","ls","dirname","relative","resolveDependency","relativeFrom","d","isDir","checkSources","isDirectory","fileChecked","fileRes","endsWith","s","startsWith","pp","builtinModules","_module","Writable","stream","pipeError","streamA","streamB","once","emit","Catchment","options","binary","rs","opts","proxyError","wrap","_","_caughtData","_promise","r","on","Buffer","concat","indexOf","pipe","chunk","encoding","callback","push","collect","readable","promise","read","mismatch","string","keys","o","p","reduce","acc","capturedGroup","key","start","RE","RE2","RE3","RE4","getMatches","a","findPackageJson","dir","name","fields","soft","fold","findEntry","entryExists","main","entry","version","packageName","rest","result","packageJson","hasMain","f","mod","JSON","parse","current","resolved","indexExists","checkIfLib","modName","getDependenciesMeta","matches","pckg","proms","internal","isLib","package","scope","paths","n","console","warn","all","Boolean","detect","cache","nodeModules","shallow","requireMatches","getRequireMatches","fm","fr","deps","dm","rm","val","required","discovered","entries","accRes","module","exports","staticAnalysis","config","detected","filtered","findIndex","fi","ii","ei","ee","ff","froms","el","newF","props"]
}
